## styled-components?

- 리엑트나 리엑트네이티브 할때 많이들 사용하는것!

```
npm install styled-components

import styled from "styled-components";
```

### 요약정리

```
let YellowBtn = styled.button`
  background : yellow;
  color: black;
  padding: 10px;
`

let Box = styled.div`
  background: grey;
  padding: 20px;
`;
 <Box>
  <YellowBtn> 버튼</YellowBtn>
</Box>
```

### 장점?

- 스타일이 다른 js파일로 오염되지 않음
- 내가볼땐 Vue에서 scoped 랑 비슷한 기능인듯
- 오염방지하려면 컴포넌트.module.css ex) **App.module.css**
- 페이지 로딩시간 단축

### 다른 버튼이 필요하면?

- props 문법쓰면됨!
- 살짝 Scss 비슷하네 ·····

```
let YellowBtn = styled.button`
  background: ${(props) => props.bg};
  color: black;
  padding: 10px;
`;

<YellowBtn bg="blue"> 버튼</YellowBtn>

let YellowBtn = styled.button`
  background: ${(props) => props.bg};
  color: ${(props) => (props.bg == "blue" ? "white" : "black")};
  padding: 10px;
`;

- 기존스타일 복붙!

let NewBtn = styled.button(YellowBtn)`
  width : 100%
`
```

### 단점

- JS파일 매우 복잡해짐
- 중복스타일은 컴포넌트간 import 할텐데 CSS와 다를바가 없음
- 협업시 CSS 담당의 숙련도 이슈

살짝하는건 styled-components 연습하려면 직접 여러가지 레이아웃을 만들어보자! 간단하게 웹단만 만들어도 무방할듯하네요

## Lifecycle

- 페이지에 장착되기도 하고 (mount)
- 가끔 업데이트도 되고 (update)
- 필요없으면 제거되고 (unmount)

```
임포트 해야함!

import useEffect from "react";

mount,update시 코드 실행해주는 useEffect

useEffect(() => {
  console.log("앙녕");
});
```

- useEffect 쓰는 이유?

**1. 랜더링이 다 되고 실행이 되는 코드임**

**2. 보통적으로 어려운 연산!!**

**3. 서버에서 데이터 가져오는 작업!!**

**4. 타이머 장착하는것**

**EFFect? 함수의 핵심기능과 상관없는 부가기능**

---

## useEffect 실행조건 넣을 수 있는 곳은 []

```
useEffect(() => {
    setTimeout(() => {
      setAlert(false);
    }, 2000);
  }, []);
```

- 컴포넌트 mount시 1회만 실행하고 싶으면 요렇게 [] 비워두기!
- return 도 추가 가능!!

```
useEffect 동작 전에 실행되는 return ()=>{} 별명 : clean up function

useEffect(() => {
    setTimeout(() => {
      setAlert(false);
    }, 2000);

    return () => {
        기존 타이머는 제거해주세요~~
        clearTimeout(time);
    }
  }, []);

  이런식
```

- 서버와 통신은??

```
useEffect(() => {
    setTimeout(() => {
      setAlert(false);
    }, 2000);

    return () => {
        기존 데이터 요청은 제거해주세요~
        clearTimeout(time);
    }
  }, []);
```

- clean up function 은 mount 시 실행안됨 unmount시 실행됨

## useEffect 제일 쉽게 설명정리

```
1. 재렌더링마다 코드 실행하고 싶으면 ?

useEffect(()=>{   })

2. mount시 1회 코드실행하고 싶으면 ?
useEffect(()=>{   }, [])

3. unmount시 1회 코드 실행하고 싶으면 ?
useEffect(()=>{
  return ()=>{

  }
},[])

4. useEffect 실행 전에 뭔가 실행하려면 언제나 return ()=> {}

5. 특정 state 변경시에만 실행하려면 [state 명]

```

## 동적 UI 만들기

- UI 상태 저장할 state 만들기
- state 따라서 UI가 어떻게 보일지 작성하기

## 서버에 데이터를 요청할 것인데

- 서버? 부탁하면 진짜로 들어주는 프로그램

1. 방법 (GET/POST)
2. 어떤자료 (URL)

```
- ajax쓰려면 옵션 3개 중 택 1

1. XMLHttpRequest
2. fetch()
3. axios

npm install axios
import axios from "axios";

onClick={() => {
  axios
    .get("https://codingapple1.github.io/shop/data2.json")
    .then((result) => {
      console.log(result.data);
    });
}}

리엑트에선 거의 서버와 ajax 이용해서 통신함

실패할 경우는?
axios
.get("https://codingapple1.github.io/shop/data2.json")
.then((result) => {
  console.log(result.data);
})
.catch(() => {
  console.log("실패");
});

```

- 리엑트는 스위치를 조작하면됩니다!

- Array안에 Array를 추가해야함!!

```
우선적으로 복사본을 만들어야함!


let copy = [...shoes, ...result.data] <- 결과에 대한 object 자료

동적인 UI만드는 법을 잘 기억해야함!!
```

## props.어쩌구가 귀찮으면

```
원본

function TabContent({props}) {
  if (props.tab === 0) {
    return <div>내용0</div>;
  } else if (props.tab === 1) {
    return <div>내용1</div>;
  } else if (props.tab === 2) {
    return <div>내용2</div>;
  }
}

꿀팁

function TabContent({tab}, props2...) {
  if (tab === 0) {
    return <div>내용0</div>;
  } else if (tab === 1) {
    return <div>내용1</div>;
  } else if (tab === 2) {
    return <div>내용2</div>;
  }
}

function TabContent({ tab }) {
  return [<div>내용0</div>, <div>내용1</div>, <div>내용2</div>][tab];
}

```

## 멋있게 컴포넌트 전환 애니메이션 주는법!

- 전환애니메이션은?

1. 애니메이션 동작 전 className 만들기

2. 애니메이션 동작 후 className 만들기

3. className에 transition 속성 추가

4. 원할 때 2번 className 부착!

4-1. 탭 state가 변할 때 end 부착!

```
function TabContent({ tab }) {
  let [fade, setFade] = useState("");

  useEffect(() => {
    setTimeout(() => {
      setFade("end");
    }, 100);
    return () => {
      setFade("");
    }; // useEffect 실행전에 적는 코드
  }, [tab]);
  return (
    <div className={`start ${fade}`}>
      {[<div>내용0</div>, <div>내용1</div>, <div>내용2</div>][tab]}
    </div>
  );
}

.start {
  opacity: 0;
}
.end {
  opacity: 1;
  transition: opacity 0.5s;
  /* opacity가 변경될때 0.5초에 걸쳐서 변경해주셈 */
}

왜 이렇게 짜야하냐면 . . .

리액트의 automatic batching 기능

state 변경함수들이 연달아서 여러개 처리되어야한다면

state 변경함수를 다 처리하고 마지막에 한 번만 재렌더링

그래서 'end' 로 변경하는거랑 ' ' 이걸로 변경하는거랑 약간 시간차를 둬야함.

찾아보면 setTimeout 말고 flushSync() 이런거 써도 될 것 같기도 합니다. automatic batching을 막아줍니다.

// 한번만 보여주면 되면

 useEffect(() => {

    setFade("end");
    return () => {
      setFade("");
    };
  },[]);

  요런식도 가능!
```

## props 싫으면 Context API

- Single Page Application 단점 : 컴포넌트간 state공유 어려움

- 컴포넌트간 state 공유 편해짐

1. Context API (리엑트 기본문법) <- 실전엔 별로안씀(참고사항)
2. Redux 등 외부 라이브러리 <- 실전에 많이씀

1-1.

```
셋팅1. let Context1 = createContext(); 위에 임포트
셋팅2. <Context> 로 원하는 컴포넌트 감싸기

<Context1.Provider value={{ 재고, shoes }}>
  <DatailPro shoes={shoes} />
</Context1.Provider>


사용 1. Context를 import
사용 2. let {재고} = useContext(Context1);

{재고}

근데 이거 안쓰는이유는?

1. state 변경시 쓸데없는 것 까지 재렌더링
2. 나중에 컴포넌트 재사용이 어려움

사실 이거보다 외부 라이브러리를 ...
```

2-2. Redux

- 컴포넌트들이 props없이 state공유가능
- react / react-dom 18v 이상!

```
npm install @reduxjs/toolkit react-redux
```

1. stroe.js 파일생성

```
import { configureStore } from "@reduxjs/toolkit";

export default configureStore({
    reducer:{

    }
})
```

2. index.js 가서 <Provider store={store}> 쓰기

```
<Provider store={store}>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </Provider>
```

## Redux store에 state 보관하는법

```

store.js

import { configureStore, createSlice } from "@reduxjs/toolkit";

let user = createSlice({
  name: "user",
  initialState: "kim",
});

export default configureStore({
  reducer: {
    작명 : user.reducer
  },
});

Cart.js

 let a = useSelector((state) => {
    return state;
  });

  console.log(a.user);

  끝!

```

### useSelector 편하게 쓰려면

```
let a = useSelector((state) => state.user);

console.log(a);

이러면 user만 return 해줌 !
```

### Redux의 state 변경! 간단한거만 props 대형은 Redux...

### step!!

1. state 수정해주는 함수 만들기

```
store.js

let user = createSlice({
  name: "user",
  initialState: "kim",
  reducers: {
    changeName(state) {
      return "john " + state; <- 'kim' 임!
    },
  },
});
```

2. 만든 함수 export 해야함

```
store.js

let user = createSlice({
  name: "user",
  initialState: "kim",
  reducers: {
    changeName(state) {
      return "john " + state;
    },
  },
});

export let { changeName, 함수1, 함수2 } = user.actions;
```

3. 만든 함수 import 해서 사용하자!

```
Cart.js


import { useDispatch, useSelector } from "react-redux";
import { changeName } from "../store";

let dispatch = useDispatch(); <- store에 보내주는 함수임

<button
  onClick={() => {
    dispatch(changeName());
  }}>
  +
</button>

```

## 근데 Redux state가 object / array 일 경우 변경하는법?

- array/object의 경우 직접수정해도 state변경됨!

- state가 array/object면 return 없이 직접 수정해도 됨!

- import 必

```
let user = createSlice({
  name: "user",
  initialState: { name: "kim", age: 20 },
  reducers: {
    changeName(state) {
      state.name = "park";
    },
    increase(state) {
      state.age++;
    },
  },
});

export let { changeName, increase } = user.actions;

let user = createSlice({
  name: "user",
  initialState: { name: "kim", age: 20 },
  reducers: {
    changeName(state) {
      state.name = "park";
    },
    increase(state, action) {
      state.age += action.payload; // state변수에 파라미터 추가 !
    },
  },
});
```

## Redux 코드가 길면?

```
- store.js

import { createSlice } from "@reduxjs/toolkit";

let user = createSlice({
  name: "user",
  initialState: { name: "kim", age: 20 },
  reducers: {
    changeName(state) {
      state.name = "park";
    },
    increase(state, action) {
      state.age += action.payload;
    },
  },
});

export default user;

- store.js

import { configureStore, createSlice } from "@reduxjs/toolkit";

import user from "./store/userSlice.js";

export let { changeName, increase } = user.actions;

```
